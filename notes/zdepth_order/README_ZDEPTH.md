# Z-Depth Shader for Sokol GP

This shader extends the standard Sokol GP shader with Z-depth support, allowing you to control the render order of 2D elements by setting a Z value in the shader.

## How it Works

The shader uses uniform data to set a Z-value for each draw call. This value is used to set the Z position in the OpenGL depth buffer, which determines the render order.

- Lower Z values (closer to 0) appear in front
- Higher Z values (closer to 1) appear in the back
- The default shader doesn't use the Z component of gl_Position, but this shader does

## Use Cases

- **Layered UIs**: Create UI elements with proper depth ordering without manually sorting your draw calls
- **2.5D Games**: Simulate depth in 2D games by assigning Z values based on Y position or game logic
- **Particle Systems**: Control which particles appear in front of others
- **Isometric Games**: Set depth based on tile position without complex sorting algorithms
- **Parallax Effects**: Assign different Z values to create parallax scrolling backgrounds

## Usage

1. **Include the shader header**
   ```c
   #include "zdepth.glsl.h"
   ```

2. **Create shader and pipeline with correct formats**
   ```c
   // Create Z-depth shader
   sg_shader shd_zdepth = sg_make_shader(zdepth_program_shader_desc(sg_query_backend()));
   
   // Create pipeline with Z-depth support - match sokol_app formats
   sgp_pipeline_desc pip_desc = {0};
   pip_desc.shader = shd_zdepth;
   pip_desc.has_vs_color = true;
   pip_desc.color_format = sapp_color_format();   // Match app color format
   pip_desc.depth_format = sapp_depth_format();   // Match app depth format
   pip_desc.sample_count = sapp_sample_count();   // Match app sample count
   sg_pipeline pip_zdepth = sgp_make_pipeline(&pip_desc);
   ```

3. **Set up Z-depth uniforms with exact structure**
   ```c
   #pragma pack(push,1)
   typedef struct {
       float z_value;
       uint8_t _pad_4[12];
       float _padding[3];
       uint8_t _pad_28[4];
   } zdepth_uniform_t;
   #pragma pack(pop)
   ```

4. **Use in rendering**
   ```c
   // Set Z-value with exact structure
   zdepth_uniform_t uniforms = {0};
   uniforms.z_value = z_value; // z_value between 0.0 and 1.0
   
   // Set custom pipeline and uniforms
   sgp_set_pipeline(pip_zdepth);
   sgp_set_uniform(&uniforms, sizeof(uniforms), NULL, 0);
   
   // Draw with custom pipeline
   sgp_draw_filled_rect(x, y, width, height);
   
   // Reset in correct order
   sgp_reset_image(0);
   sgp_reset_sampler(0);
   sgp_reset_uniform();
   sgp_reset_pipeline();
   ```

## Common Patterns

### Automatic Y-Based Depth

For top-down games where objects lower on screen should appear in front:

```c
// Calculate Z from Y position (lower Y = higher on screen = further back)
float z_value = y_position / screen_height;
```

### Layered UI

For UI with fixed layers:

```c
// Define your layers
#define LAYER_BACKGROUND 0.9f
#define LAYER_MIDGROUND  0.5f
#define LAYER_FOREGROUND 0.1f
#define LAYER_UI         0.0f

// Use the appropriate layer when drawing
draw_rect_with_zdepth(x, y, width, height, color, LAYER_MIDGROUND, texture);
```

### Dynamic Depth from Game Logic

```c
// For an isometric game, calculate Z from tile coordinates
float z_value = (float)(x_tile + y_tile) / (max_x + max_y);
```

## Important Notes

1. **Match Color and Depth Formats** (Critical):
   - Always use the correct color and depth formats from sokol_app:
   ```c
   // Initialize Sokol GP with matching formats
   sgp_desc sgpdesc = {0};
   sgpdesc.color_format = sapp_color_format();
   sgpdesc.depth_format = sapp_depth_format();
   sgpdesc.sample_count = sapp_sample_count();
   ```

2. Ensure depth testing is enabled with the proper pass_action setup:
   ```c
   sg_pass_action pass_action = {
       .colors[0] = { .load_action = SG_LOADACTION_CLEAR, .clear_value = {0.0f, 0.0f, 0.0f, 1.0f} },
       .depth = { .load_action = SG_LOADACTION_CLEAR, .clear_value = 1.0f }
   };
   ```

3. Remember that OpenGL's depth buffer works with values between 0 and 1, with 0 being the closest to the camera. The shader uses `1.0 - z_value` to make larger Z values appear further back.

4. When using transparency, ensure your objects are drawn from back to front or use proper alpha blending.

5. **Critical: Uniform Alignment**
   - The uniform structure **must exactly match** what's generated by sokol-shdc
   - You can see the exact structure by looking at the generated shader header
   - The structure is 32 bytes total with specific padding requirements

6. **Critical: Reset Order**
   - Always reset in the correct order: images/samplers first, then uniforms, then pipeline
   - Resetting uniforms requires an active pipeline, so reset uniforms before the pipeline

## Fallback: Painter's Algorithm

On some platforms or specific contexts, hardware depth testing may not function as expected with sokol_gp. In these cases, implement the painter's algorithm as a fallback:

```c
// Define a struct for objects with depth
typedef struct {
    float x, y;
    float z;
    sgp_color color;
    sg_image image;
} rect_with_depth;

// Sort objects from back to front
// Example using bubble sort for simplicity
for (int i = 0; i < n-1; i++) {
    for (int j = 0; j < n-i-1; j++) {
        if (rects[j].z < rects[j+1].z) {
            // Swap - higher Z values drawn first
            rect_with_depth temp = rects[j];
            rects[j] = rects[j+1];
            rects[j+1] = temp;
        }
    }
}

// Draw from back to front (painter's algorithm)
for (int i = 0; i < n; i++) {
    draw_rect_with_zdepth(
        rects[i].x, 
        rects[i].y, 
        width, 
        height, 
        rects[i].color, 
        rects[i].z,
        rects[i].image
    );
}
```

## Integrating with Existing Code

To integrate the Z-depth shader with existing sokol_gp code:

1. Create a helper function for Z-depth drawing:
   ```c
   void draw_with_depth(float x, float y, float width, float height, 
                        sgp_color color, float z, sg_image texture) {
       // Implementation as shown in "Use in rendering" section
   }
   ```

2. Replace your calls to `sgp_draw_*` functions with your new helper function when Z-ordering is needed.

3. For other drawing operations that don't need Z-depth control, continue using the standard sokol_gp pipeline.

## Performance Considerations

- The Z-depth shader has minimal overhead compared to the standard shader
- Pipeline switches can be expensive, so batch similar depth objects together
- For very large numbers of objects, consider implementing a batching system that sorts by texture first, then Z value
- When using the painter's algorithm fallback, use an efficient sorting algorithm for large numbers of objects

## Troubleshooting

- **Uniform Size Errors**: Ensure you're using the exact structure layout shown above
- **Objects Not Appearing**: Check that your Z values are between 0.0 and 1.0
- **Flickering**: You may have Z-fighting; try using more separated Z values
- **Transparent Objects Issues**: Draw transparent objects from back to front
- **Color Format Errors**: Make sure you're matching the color and depth formats from sokol_app
- **Depth Testing Not Working**: Some platforms may have limitations with sokol_gp's depth testing; use the painter's algorithm fallback

## Example

See `samples/sample-zdepth.c` for a complete working example of how to use the Z-depth shader for controlling render order in Sokol GP. 