/*
This sample demonstrates how to use Z-depth ordering with sokol_gp.
Objects with higher Z values appear behind those with lower Z values.
*/

#define SGP_UNIFORM_CONTENT_SLOTS 16
#define SOKOL_IMPL
#include "sokol_gfx.h"
#include "sokol_gp.h"
#include "sokol_app.h"
#include "sokol_glue.h"
#include "sokol_log.h"
#include "sokol_time.h"

#define STB_IMAGE_IMPLEMENTATION
#define STB_IMAGE_STATIC
#define STBI_NO_SIMD
#define STBI_ONLY_PNG
#include "stb_image.h"

#define SOKOL_SHDC_IMPL
#include "zdepth.glsl.h"

// Pipeline with Z-depth support
static sg_pipeline pip_zdepth;
static sg_shader shd_zdepth;
static sg_sampler linear_sampler;

// For uniform data - use exactly the same structure as generated by sokol-shdc
#pragma pack(push,1)
typedef struct {
    float z_value;
    uint8_t _pad_4[12];
    float _padding[3];
    uint8_t _pad_28[4];
} zdepth_uniform_t;
#pragma pack(pop)

// Images for demonstration
static sg_image image_front;
static sg_image image_middle;
static sg_image image_back;

// For animation
static uint64_t start_time;
static bool animate_depth = true;

// Function to draw a rectangle with z-depth
static void draw_rect_with_zdepth(float x, float y, float width, float height, sgp_color color, float z, sg_image img) {
    // Set the Z value in uniform data with proper padding/alignment
    zdepth_uniform_t uniforms = {0};
    uniforms.z_value = z;
    
    // Set the custom pipeline and image
    sgp_set_pipeline(pip_zdepth);
    sgp_set_uniform(&uniforms, sizeof(uniforms), NULL, 0);
    sgp_set_image(0, img);
    sgp_set_sampler(0, linear_sampler);
    
    // Draw the rectangle with the specified color
    sgp_set_color(color.r, color.g, color.b, color.a);
    sgp_draw_filled_rect(x, y, width, height);
    
    // Reset pipeline and resources - note the correct order
    sgp_reset_image(0);
    sgp_reset_sampler(0);
    sgp_reset_uniform();
    sgp_reset_pipeline();
}

static void frame(void) {
    // begin draw commands queue
    int window_width = sapp_width(), window_height = sapp_height();
    sgp_begin(window_width, window_height);
    
    // Clear the background
    sgp_set_color(0.1f, 0.1f, 0.1f, 1.0f);
    sgp_clear();
    
    // Draw three overlapping rectangles with different Z values
    float box_size = 200.0f;
    float center_x = window_width / 2.0f - box_size / 2.0f;
    float center_y = window_height / 2.0f - box_size / 2.0f;
    
    // Calculate animated Z values (oscillate between 0 and 1)
    float time_sec = stm_sec(stm_diff(stm_now(), start_time));
    float z_front = animate_depth ? fabsf(sinf(time_sec * 0.5f)) : 0.2f; 
    float z_middle = animate_depth ? fabsf(sinf(time_sec * 0.5f + 2.094f)) : 0.5f; // 2PI/3 offset
    float z_back = animate_depth ? fabsf(sinf(time_sec * 0.5f + 4.188f)) : 0.8f;   // 4PI/3 offset
    
    // Back rectangle (blue)
    draw_rect_with_zdepth(
        center_x - 100.0f, 
        center_y - 100.0f, 
        box_size, 
        box_size, 
        (sgp_color){0.0f, 0.0f, 0.8f, 0.8f}, 
        z_back,
        image_back
    );
    
    // Middle rectangle (green)
    draw_rect_with_zdepth(
        center_x, 
        center_y, 
        box_size, 
        box_size, 
        (sgp_color){0.0f, 0.8f, 0.0f, 0.8f}, 
        z_middle,
        image_middle
    );
    
    // Front rectangle (red)
    draw_rect_with_zdepth(
        center_x + 100.0f, 
        center_y + 100.0f, 
        box_size, 
        box_size, 
        (sgp_color){0.8f, 0.0f, 0.0f, 0.8f}, 
        z_front,
        image_front
    );
    
    // Draw instructions
    sgp_reset_pipeline();
    sgp_set_color(1.0f, 1.0f, 1.0f, 1.0f);
    char info_text[128];
    snprintf(info_text, sizeof(info_text), 
             "Red Z: %.2f   Green Z: %.2f   Blue Z: %.2f   [Space] Toggle Animation", 
             z_front, z_middle, z_back);
    // Note: In a real app, you'd use a proper text rendering solution
    
    // dispatch draw commands
    sg_pass_action pass_action = {
        .colors[0] = { .load_action = SG_LOADACTION_CLEAR, .clear_value = {0.0f, 0.0f, 0.0f, 1.0f} },
        .depth = { .load_action = SG_LOADACTION_CLEAR, .clear_value = 1.0f }
    };
    sg_pass pass = {
        .action = pass_action,
        .swapchain = sglue_swapchain()
    };
    sg_begin_pass(&pass);
    sgp_flush();
    sgp_end();
    sg_end_pass();
    sg_commit();
}

static void event(const sapp_event* ev) {
    if (ev->type == SAPP_EVENTTYPE_KEY_DOWN) {
        if (ev->key_code == SAPP_KEYCODE_SPACE) {
            animate_depth = !animate_depth;
        }
    }
}

static sg_image load_image(const char *filename) {
    int width, height, channels;
    uint8_t* data = stbi_load(filename, &width, &height, &channels, 4);
    sg_image img = {SG_INVALID_ID};
    if (!data) {
        return img;
    }
    sg_image_desc image_desc = {0};
    image_desc.width = width;
    image_desc.height = height;
    image_desc.data.subimage[0][0].ptr = data;
    image_desc.data.subimage[0][0].size = (size_t)(width * height * 4);
    img = sg_make_image(&image_desc);
    stbi_image_free(data);
    return img;
}

static void init(void) {
    // Initialize time measurement
    stm_setup();
    start_time = stm_now();
    
    // Initialize Sokol GFX
    sg_desc sgdesc = {
        .environment = sglue_environment(),
        .logger.func = slog_func,
        .buffer_pool_size = 128,
        .image_pool_size = 128
    };
    sg_setup(&sgdesc);
    if (!sg_isvalid()) {
        fprintf(stderr, "Failed to create Sokol GFX context!\n");
        exit(-1);
    }

    // Initialize Sokol GP
    sgp_desc sgpdesc = {0};
    sgp_setup(&sgpdesc);
    if (!sgp_is_valid()) {
        fprintf(stderr, "Failed to create Sokol GP context: %s\n", sgp_get_error_message(sgp_get_last_error()));
        exit(-1);
    }

    // Load test images
    image_front = load_image("images/front.png");
    image_middle = load_image("images/middle.png");
    image_back = load_image("images/back.png");
    
    // If images failed to load, use placeholder colors
    if (sg_query_image_state(image_front) != SG_RESOURCESTATE_VALID) {
        sg_image_desc img_desc = {
            .width = 1,
            .height = 1,
            .data.subimage[0][0] = { .ptr = (uint8_t[]){255, 0, 0, 255}, .size = 4 }
        };
        image_front = sg_make_image(&img_desc);
    }
    if (sg_query_image_state(image_middle) != SG_RESOURCESTATE_VALID) {
        sg_image_desc img_desc = {
            .width = 1,
            .height = 1,
            .data.subimage[0][0] = { .ptr = (uint8_t[]){0, 255, 0, 255}, .size = 4 }
        };
        image_middle = sg_make_image(&img_desc);
    }
    if (sg_query_image_state(image_back) != SG_RESOURCESTATE_VALID) {
        sg_image_desc img_desc = {
            .width = 1,
            .height = 1,
            .data.subimage[0][0] = { .ptr = (uint8_t[]){0, 0, 255, 255}, .size = 4 }
        };
        image_back = sg_make_image(&img_desc);
    }

    // Create linear sampler
    sg_sampler_desc linear_sampler_desc = {
        .min_filter = SG_FILTER_LINEAR,
        .mag_filter = SG_FILTER_LINEAR,
        .wrap_u = SG_WRAP_CLAMP_TO_EDGE,
        .wrap_v = SG_WRAP_CLAMP_TO_EDGE,
    };
    linear_sampler = sg_make_sampler(&linear_sampler_desc);

    // Initialize Z-depth shader
    shd_zdepth = sg_make_shader(zdepth_program_shader_desc(sg_query_backend()));
    if (sg_query_shader_state(shd_zdepth) != SG_RESOURCESTATE_VALID) {
        fprintf(stderr, "Failed to create Z-depth shader!\n");
        exit(-1);
    }

    // Create pipeline with Z-depth support
    sgp_pipeline_desc pip_desc = {0};
    pip_desc.shader = shd_zdepth;
    pip_desc.has_vs_color = true;
    pip_zdepth = sgp_make_pipeline(&pip_desc);
    if (sg_query_pipeline_state(pip_zdepth) != SG_RESOURCESTATE_VALID) {
        fprintf(stderr, "Failed to create Z-depth pipeline!\n");
        exit(-1);
    }
}

static void cleanup(void) {
    sg_destroy_image(image_front);
    sg_destroy_image(image_middle);
    sg_destroy_image(image_back);
    sg_destroy_sampler(linear_sampler);
    sg_destroy_pipeline(pip_zdepth);
    sg_destroy_shader(shd_zdepth);
    sgp_shutdown();
    sg_shutdown();
}

sapp_desc sokol_main(int argc, char* argv[]) {
    (void)argc;
    (void)argv;
    return (sapp_desc){
        .init_cb = init,
        .frame_cb = frame,
        .event_cb = event,
        .cleanup_cb = cleanup,
        .window_title = "Z-Depth Ordering (Sokol GP)",
        .logger.func = slog_func,
        .width = 800,
        .height = 600,
        .sample_count = 4
    };
} 