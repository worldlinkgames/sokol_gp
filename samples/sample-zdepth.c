/*
This sample demonstrates how to use Z-depth ordering with sokol_gp.
Objects with higher Z values appear behind those with lower Z values.
*/

#define SGP_UNIFORM_CONTENT_SLOTS 16
#define SOKOL_IMPL
#include "sokol_gfx.h"
#include "sokol_gp.h"
#include "sokol_app.h"
#include "sokol_glue.h"
#include "sokol_log.h"
#include "sokol_time.h"

#define STB_IMAGE_IMPLEMENTATION
#define STB_IMAGE_STATIC
#define STBI_NO_SIMD
#define STBI_ONLY_PNG
#include "stb_image.h"

#define SOKOL_SHDC_IMPL
#include "zdepth.glsl.h"

// Pipeline with Z-depth support
static sg_pipeline pip_zdepth;
static sg_shader shd_zdepth;
static sg_sampler linear_sampler;

// For uniform data - use exactly the same structure as generated by sokol-shdc
#pragma pack(push,1)
typedef struct {
    float z_value;
    uint8_t _pad_4[12];
    float _padding[3];
    uint8_t _pad_28[4];
} zdepth_uniform_t;
#pragma pack(pop)

// Images for demonstration
static sg_image image_front;
static sg_image image_middle;
static sg_image image_back;

// For animation
static uint64_t start_time;
static bool animate_depth = true;

static sg_pipeline custom_depth_pipeline;

// Function to draw a rectangle with z-depth
static void draw_rect_with_zdepth(float x, float y, float width, float height, sgp_color color, float z, sg_image img) {
    // Debug the Z value - values should range from 0 to 1
    // Z=0 is front (near), Z=1 is back (far)
    static float last_z_print = 0.0f;
    static float last_z_print_time = 0.0f;
    float current_time = stm_sec(stm_diff(stm_now(), start_time));
    
    // Only print occasionally to avoid spam
    if (current_time - last_z_print_time > 2.0f) {
        printf("Drawing rect with position (%.1f,%.1f) and Z: %.2f\n", x, y, z);
        last_z_print_time = current_time;
        last_z_print = z;
    }

    // Set the Z value in uniform data with proper padding/alignment
    zdepth_uniform_t uniforms = {0};
    uniforms.z_value = z;
    
    // Set the custom pipeline and image
    // sgp_set_pipeline(pip_zdepth);
    sgp_set_pipeline(custom_depth_pipeline);
    
    // Set the blend mode for proper alpha handling
    sgp_set_blend_mode(SGP_BLENDMODE_BLEND);
    
    // Set the uniform with Z value
    sgp_set_uniform(&uniforms, sizeof(uniforms), NULL, 0);
    sgp_set_image(0, img);
    sgp_set_sampler(0, linear_sampler);
    
    // Draw the rectangle with the specified color
    sgp_set_color(color.r, color.g, color.b, color.a);
    sgp_draw_filled_rect(x, y, width, height);
    
    // Reset pipeline and resources - note the correct order
    sgp_reset_image(0);
    sgp_reset_sampler(0);
    sgp_reset_uniform();
    sgp_reset_blend_mode();
    sgp_reset_pipeline();
}

static void frame(void) {
    // begin draw commands queue
    int window_width = sapp_width(), window_height = sapp_height();
    sgp_begin(window_width, window_height);
    
    // Clear the background
    sgp_set_color(0.1f, 0.1f, 0.1f, 1.0f);
    sgp_clear();
    
    // Draw three overlapping rectangles with different Z values
    float box_size = 200.0f;
    float center_x = window_width / 2.0f - box_size / 2.0f;
    float center_y = window_height / 2.0f - box_size / 2.0f;
    
    // Calculate animated Z values (oscillate between 0 and 1)
    float time_sec = stm_sec(stm_diff(stm_now(), start_time));
    
    // Debug message for animation state - less frequent to avoid console spam
    static float last_print_time = 0.0f;
    if (time_sec - last_print_time > 5.0f) {
        printf("Animation state: %s (time: %.2f)\n", animate_depth ? "ON" : "OFF", time_sec);
        last_print_time = time_sec;
    }
    
    // More distinct Z values - wider range for better visualization
    float z_front, z_middle, z_back;
    
    if (animate_depth) {
        // Use more pronounced animation with faster and wider oscillation
        // Note: The shader uses 1.0 - z_value, so higher values move objects backward
        z_front = 0.1f + 0.8f * fabsf(sinf(time_sec));
        z_middle = 0.1f + 0.8f * fabsf(sinf(time_sec + 2.094f)); // 2PI/3 offset
        z_back = 0.1f + 0.8f * fabsf(sinf(time_sec + 4.188f));   // 4PI/3 offset
    } else {
        // Fixed Z values
        z_front = 0.9f;  // Closer to screen (higher z = further in OpenGL)
        z_middle = 0.5f; // Middle depth
        z_back = 0.1f;   // Farther from screen (lower z = closer in OpenGL)
    }
    
    // Print Z values periodically for debugging
    printf("Z values: blue=%.2f (pos=back), green=%.2f (pos=middle), red=%.2f (pos=front)\n", 
           z_back, z_middle, z_front);
    
    // Define the rectangles we want to draw
    typedef struct {
        float x, y;
        float z;
        sgp_color color;
        sg_image image;
        const char* name;
    } rect_with_depth;
    
    rect_with_depth rects[] = {
        // Back rectangle (blue)
        {
            .x = center_x - 100.0f,
            .y = center_y - 100.0f,
            .z = z_back,
            .color = {0.0f, 0.0f, 0.8f, 0.8f},
            .image = image_back,
            .name = "blue"
        },
        // Middle rectangle (green)
        {
            .x = center_x,
            .y = center_y,
            .z = z_middle,
            .color = {0.0f, 0.8f, 0.0f, 0.8f},
            .image = image_middle,
            .name = "green"
        },
        // Front rectangle (red)
        {
            .x = center_x + 100.0f,
            .y = center_y + 100.0f,
            .z = z_front,
            .color = {0.8f, 0.0f, 0.0f, 0.8f},
            .image = image_front,
            .name = "red"
        }
    };
    
    // Sort the rectangles by Z value (back to front - painter's algorithm)
    // Simple bubble sort since we only have 3 elements
    int n = sizeof(rects) / sizeof(rects[0]);
    // for (int i = 0; i < n-1; i++) {
    //     for (int j = 0; j < n-i-1; j++) {
    //         if (rects[j].z < rects[j+1].z) {
    //             // Swap
    //             rect_with_depth temp = rects[j];
    //             rects[j] = rects[j+1];
    //             rects[j+1] = temp;
    //         }
    //     }
    // }
    
    // Draw rectangles in sorted order (back to front)
    printf("Drawing order: ");
    for (int i = 0; i < n; i++) {
        draw_rect_with_zdepth(
            rects[i].x, 
            rects[i].y, 
            box_size, 
            box_size, 
            rects[i].color, 
            rects[i].z,
            rects[i].image
        );
        printf("%s (z=%.2f) ", rects[i].name, rects[i].z);
    }
    printf("\n");
    
    // Overlay explanatory text
    sgp_reset_pipeline();
    sgp_set_color(1.0f, 1.0f, 1.0f, 1.0f);
    char info_text[128];
    snprintf(info_text, sizeof(info_text), 
             "Red Z: %.2f   Green Z: %.2f   Blue Z: %.2f   [Space] Toggle Animation", 
             z_front, z_middle, z_back);
    // Note: In a real app, you'd use a proper text rendering solution
    
    // dispatch draw commands
    sg_pass_action pass_action = {
        .colors[0] = { .load_action = SG_LOADACTION_CLEAR, .clear_value = {0.0f, 0.0f, 0.0f, 1.0f} },
        .depth = { .load_action = SG_LOADACTION_CLEAR, .clear_value = 1.0f }
    };
    sg_pass pass = {
        .action = pass_action,
        .swapchain = sglue_swapchain()
    };
    sg_begin_pass(&pass);
    sgp_flush();
    sgp_end();
    sg_end_pass();
    sg_commit();
}

static void event(const sapp_event* ev) {
    // Log all key events to see if they're coming through
    if (ev->type == SAPP_EVENTTYPE_KEY_DOWN) {
        printf("Key pressed: %d\n", ev->key_code);
        
        if (ev->key_code == SAPP_KEYCODE_SPACE) {
            animate_depth = !animate_depth;
            printf("Animation toggled: %s\n", animate_depth ? "ON" : "OFF");
        }
    }
}

static sg_image load_image(const char *filename) {
    int width, height, channels;
    uint8_t* data = stbi_load(filename, &width, &height, &channels, 4);
    sg_image img = {SG_INVALID_ID};
    if (!data) {
        return img;
    }
    sg_image_desc image_desc = {0};
    image_desc.width = width;
    image_desc.height = height;
    image_desc.data.subimage[0][0].ptr = data;
    image_desc.data.subimage[0][0].size = (size_t)(width * height * 4);
    img = sg_make_image(&image_desc);
    stbi_image_free(data);
    return img;
}

static void init(void) {
    // Initialize time measurement
    stm_setup();
    start_time = stm_now();
    
    // Initialize Sokol GFX
    sg_desc sgdesc = {
        .environment = sglue_environment(),
        .logger.func = slog_func,
        .buffer_pool_size = 128,
        .image_pool_size = 128
    };
    sg_setup(&sgdesc);
    if (!sg_isvalid()) {
        fprintf(stderr, "Failed to create Sokol GFX context!\n");
        exit(-1);
    }

    // Initialize Sokol GP
    sgp_desc sgpdesc = {0};
    sgpdesc.max_vertices = 65536;       // Increased from default for complex rendering
    sgpdesc.max_commands = 16384;       // Increased from default
    
    // Use the actual color and depth formats of the framebuffer
    sgpdesc.color_format = sapp_color_format();  // Get format from sokol_app
    sgpdesc.depth_format = sapp_depth_format();  // Get format from sokol_app
    sgpdesc.sample_count = sapp_sample_count();  // Get sample count from sokol_app
    
    printf("Using color format: %d, depth format: %d, sample count: %d\n", 
           sgpdesc.color_format, sgpdesc.depth_format, sgpdesc.sample_count);
    
    sgp_setup(&sgpdesc);
    if (!sgp_is_valid()) {
        fprintf(stderr, "Failed to create Sokol GP context: %s\n", sgp_get_error_message(sgp_get_last_error()));
        exit(-1);
    }

    // Load test images
    image_front = load_image("images/front.png");
    image_middle = load_image("images/middle.png");
    image_back = load_image("images/back.png");
    
    // If images failed to load, use placeholder colors
    if (sg_query_image_state(image_front) != SG_RESOURCESTATE_VALID) {
        sg_image_desc img_desc = {
            .width = 1,
            .height = 1,
            .data.subimage[0][0] = { .ptr = (uint8_t[]){255, 0, 0, 255}, .size = 4 }
        };
        image_front = sg_make_image(&img_desc);
    }
    if (sg_query_image_state(image_middle) != SG_RESOURCESTATE_VALID) {
        sg_image_desc img_desc = {
            .width = 1,
            .height = 1,
            .data.subimage[0][0] = { .ptr = (uint8_t[]){0, 255, 0, 255}, .size = 4 }
        };
        image_middle = sg_make_image(&img_desc);
    }
    if (sg_query_image_state(image_back) != SG_RESOURCESTATE_VALID) {
        sg_image_desc img_desc = {
            .width = 1,
            .height = 1,
            .data.subimage[0][0] = { .ptr = (uint8_t[]){0, 0, 255, 255}, .size = 4 }
        };
        image_back = sg_make_image(&img_desc);
    }

    // Create linear sampler
    sg_sampler_desc linear_sampler_desc = {
        .min_filter = SG_FILTER_LINEAR,
        .mag_filter = SG_FILTER_LINEAR,
        .wrap_u = SG_WRAP_CLAMP_TO_EDGE,
        .wrap_v = SG_WRAP_CLAMP_TO_EDGE,
    };
    linear_sampler = sg_make_sampler(&linear_sampler_desc);

    // Initialize Z-depth shader
    shd_zdepth = sg_make_shader(zdepth_program_shader_desc(sg_query_backend()));
    if (sg_query_shader_state(shd_zdepth) != SG_RESOURCESTATE_VALID) {
        fprintf(stderr, "Failed to create Z-depth shader!\n");
        exit(-1);
    }

    // Create pipeline with Z-depth support
    sgp_pipeline_desc sgp_pip_desc = {0};
    sgp_pip_desc.shader = shd_zdepth;
    sgp_pip_desc.has_vs_color = true;
    sgp_pip_desc.primitive_type = SG_PRIMITIVETYPE_TRIANGLES;
    sgp_pip_desc.blend_mode = SGP_BLENDMODE_BLEND_PREMULTIPLIED;
    sgp_pip_desc.color_format = sgpdesc.color_format;
    sgp_pip_desc.depth_format = sgpdesc.depth_format;
    sgp_pip_desc.sample_count = sgpdesc.sample_count;

    // Create the sokol_gp pipeline
    pip_zdepth = sgp_make_pipeline(&sgp_pip_desc);

    // Now create a direct sokol_gfx pipeline with depth testing
    sg_pipeline_desc sg_pip_desc = {0};
    sg_pip_desc.shader = shd_zdepth;
    sg_pip_desc.layout.buffers[0].stride = sizeof(sgp_vertex);
    sg_pip_desc.layout.attrs[0].format = SG_VERTEXFORMAT_FLOAT4;
    sg_pip_desc.layout.attrs[0].offset = offsetof(sgp_vertex, position);
    sg_pip_desc.layout.attrs[1].format = SG_VERTEXFORMAT_UBYTE4N;
    sg_pip_desc.layout.attrs[1].offset = offsetof(sgp_vertex, color);
    sg_pip_desc.depth.pixel_format = sgpdesc.depth_format;
    sg_pip_desc.depth.write_enabled = true;
    sg_pip_desc.depth.compare = SG_COMPAREFUNC_LESS_EQUAL;
    sg_pip_desc.colors[0].pixel_format = sgpdesc.color_format;
    sg_pip_desc.primitive_type = SG_PRIMITIVETYPE_TRIANGLES;

    // Create a direct pipeline with sokol_gfx
    custom_depth_pipeline = sg_make_pipeline(&sg_pip_desc);
}

static void cleanup(void) {
    sg_destroy_image(image_front);
    sg_destroy_image(image_middle);
    sg_destroy_image(image_back);
    sg_destroy_sampler(linear_sampler);
    sg_destroy_pipeline(pip_zdepth);
    sg_destroy_shader(shd_zdepth);
    sgp_shutdown();
    sg_shutdown();
}

sapp_desc sokol_main(int argc, char* argv[]) {
    (void)argc;
    (void)argv;
    return (sapp_desc){
        .init_cb = init,
        .frame_cb = frame,
        .event_cb = event,
        .cleanup_cb = cleanup,
        .window_title = "Z-Depth Ordering (Sokol GP)",
        .logger.func = slog_func,
        .width = 800,
        .height = 600,
        .sample_count = 4
        // Note: depth_buffer field is not available in this sokol_app version
    };
} 